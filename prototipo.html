<!DOCTYPE html>
<html lang="pt-BR">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeBlocos - Programa√ß√£o Visual Animada</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blockly/9.3.3/blockly.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blockly/9.3.3/blocks.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blockly/9.3.3/javascript.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/blockly/9.3.3/msg/pt-br.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            overflow: hidden;
        }

        .navbar {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            padding: 1rem 2rem;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .logo {
            font-size: 1.8rem;
            font-weight: bold;
            color: white;
        }

        .logo span {
            color: #ffd700;
        }

        .nav-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .main-container {
            padding: 1rem;
            height: calc(100vh - 80px);
        }

        .coding-area {
            background: white;
            border-radius: 15px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        .code-title {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem 2rem;
            background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
            color: white;
            flex-shrink: 0;
        }

        .code-title h2 {
            font-size: 1.5rem;
            font-weight: 600;
        }

        .title-center {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            padding: 1em;
        }

        .action-buttons {
            display: flex;
            gap: 0.5rem;
            flex-wrap: wrap;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.3s ease;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 0.3rem;
        }

        .btn-secondary {
            background: rgba(255, 255, 255, 0.2);
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: translateY(-2px);
        }

        .btn-success {
            background: #2dcc70;
            color: white;
        }

        .btn-success:hover {
            background: #27ae60;
            transform: translateY(-2px);
        }

        .btn-danger {
            background: #e74c3c;
            color: white;
        }

        .btn-danger:hover {
            background: #c0392b;
            transform: translateY(-2px);
        }

        .workspace-container {
            display: flex;
            height: 100%;
            flex: 1;
        }

        #blocklyDiv {
            flex: 1;
            min-width: 400px;
            background: #f8f9fa;
        }

        .visualization-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            border-left: 2px solid #ecf0f1;
            min-width: 450px;
        }

        .preview-container {
            flex: 1;
            background: #f8f9fa;
            position: relative;
            overflow: hidden;
        }

        .canvas-container {
            width: 100%;
            height: 100%;
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        #drawCanvas {
            border: 2px solid #bdc3c7;
            border-radius: 10px;
            background: white;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }

        #turtleCanvas {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            border-radius: 10px;
        }

        .tooltip-box {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(52, 73, 94, 0.95);
            color: white;
            padding: 1rem;
            border-radius: 8px;
            max-width: 280px;
            font-size: 0.9rem;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            z-index: 100;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }

        .tooltip-box h4 {
            margin-bottom: 0.5rem;
            color: #ffd700;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .close-btn {
            background: none;
            border: none;
            color: #ffd700;
            font-size: 1.2rem;
            cursor: pointer;
            padding: 0;
            margin-left: 10px;
            transition: color 0.3s ease;
        }

        .close-btn:hover {
            color: #ff6b6b;
        }

        .tooltip-box.hidden {
            opacity: 0;
            transform: translateX(-100%);
            pointer-events: none;
        }

        .console-container {
            height: 180px;
            background: #2c3e50;
            color: #ecf0f1;
            padding: 1rem;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            border-top: 2px solid #34495e;
            flex-shrink: 0;
        }

        .console-line {
            margin-bottom: 0.3rem;
            animation: fadeIn 0.3s ease-in;
            word-wrap: break-word;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .speed-control {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.75rem;
            border-radius: 10px;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .speed-slider {
            width: 100px;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .speed-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4facfe;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .canvas-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            padding: 0.60rem;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.6rem;
            backdrop-filter: blur(5px);
            min-width: 100px;
        }

        .grid-toggle {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.9);
            border: none;
            padding: 0.5rem;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            transition: all 0.3s ease;
        }

        .grid-toggle:hover {
            background: white;
            transform: translateY(-2px);
        }

        .character-trail {
            position: absolute;
            border-radius: 50%;
            pointer-events: none;
            animation: trailFade 1.5s ease-out forwards;
        }

        @keyframes trailFade {
            0% {
                opacity: 0.8;
                transform: scale(1);
            }

            100% {
                opacity: 0;
                transform: scale(0.2);
            }
        }

        .sparkle {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            pointer-events: none;
            animation: sparkleAnim 1s ease-out forwards;
        }

        @keyframes sparkleAnim {
            0% {
                opacity: 1;
                transform: scale(0) rotate(0deg);
            }

            50% {
                opacity: 1;
                transform: scale(1) rotate(180deg);
            }

            100% {
                opacity: 0;
                transform: scale(0) rotate(360deg);
            }
        }

        .error-message {
            color: #e74c3c;
            background: rgba(231, 76, 60, 0.1);
            border-left: 4px solid #e74c3c;
            padding: 0.5rem;
            margin: 0.3rem 0;
        }

        .success-message {
            color: #27ae60;
            background: rgba(39, 174, 96, 0.1);
            border-left: 4px solid #27ae60;
            padding: 0.5rem;
            margin: 0.3rem 0;
        }

        .zoom-controls {
            position: absolute;
            top: 80px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            background: rgba(255, 255, 255, 0.95);
            padding: 0.75rem;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }

        .zoom-btn {
            width: 40px;
            height: 40px;
            border: none;
            border-radius: 8px;
            background: #4facfe;
            color: white;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .zoom-btn:hover {
            background: #3d8bfe;
            transform: scale(1.1);
        }

        .zoom-reset {
            background: #6c757d;
            font-size: 0.8rem;
            height: 30px;
        }

        .zoom-reset:hover {
            background: #5a6268;
        }

        .canvas-wrapper {
            transition: transform 0.3s ease;
            transform-origin: center center;
        }

        @media (max-width: 1024px) {
            .workspace-container {
                flex-direction: column;
            }

            #blocklyDiv {
                min-height: 300px;
                flex: 0 0 300px;
            }

            .visualization-area {
                border-left: none;
                border-top: 2px solid #ecf0f1;
                min-width: auto;
            }

            .action-buttons {
                flex-wrap: wrap;
                gap: 0.3rem;
            }

            .btn {
                font-size: 0.8rem;
                padding: 0.4rem 0.8rem;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                padding: 0.5rem;
            }

            .code-title {
                padding: 1rem;
                flex-direction: column;
                gap: 1rem;
                align-items: stretch;
            }

            .tooltip-box {
                position: relative;
                margin-bottom: 1rem;
            }

            .speed-control,
            .canvas-info,
            .grid-toggle {
                position: relative;
                margin: 0.5rem;
            }
        }
    </style>
</head>

<body>
    <div class="navbar">
        <div class="logo">Code<span>Blocos</span></div>
        <div class="nav-controls">
            <span style="color: rgba(255,255,255,0.8); font-size: 0.9rem;">Programa√ß√£o Visual Educativa</span>
        </div>
    </div>

    <div class="main-container">
        <div class="coding-area">
            <div class="code-title">
                <h2>üé® Meu Programa Animado</h2>
                <div class="title-center">
                    <button onclick="loadExample('square')" class="btn btn-secondary"
                        title="Carregar exemplo: Quadrado">
                        üü™ Quadrado
                    </button>
                    <button onclick="loadExample('spiral')" class="btn btn-secondary" title="Carregar exemplo: Espiral">
                        üåÄ Espiral
                    </button>
                    <button onclick="loadExample('flower')" class="btn btn-secondary" title="Carregar exemplo: Flor">
                        üå∏ Flor
                    </button>
                </div>
                <div class="action-buttons">


                    <button id="loadButton" class="btn btn-secondary" title="Carregar programa">
                        üìÇ Carregar
                    </button>
                    <button id="saveButton" class="btn btn-secondary" title="Salvar programa">
                        üíæ Salvar
                    </button>
                    <button id="exportButton" class="btn btn-secondary" title="Exportar desenho">
                        üñºÔ∏è Exportar
                    </button>
                    <button id="runButton" class="btn btn-success" title="Executar programa">
                        ‚ñ∂Ô∏è Executar
                    </button>
                    <button id="stopButton" class="btn btn-danger" title="Parar execu√ß√£o" disabled>
                        ‚èπÔ∏è Parar
                    </button>
                    <button id="resetButton" class="btn btn-secondary" title="Reiniciar canvas">
                        üîÑ Limpar
                    </button>
                    <button id="tipsButton" class="btn btn-secondary" title="Mostrar/ocultar dicas">
                        üí° Dicas
                    </button>
                    <button class="btn btn-secondary" onclick="resizeConsole(20)">üîº Console</button>
                    <button class="btn btn-secondary" onclick="resizeConsole(-20)">üîΩ Console</button>
                </div>
            </div>

            <div class="workspace-container">
                <div id="blocklyDiv"></div>

                <div class="visualization-area">
                    <div class="preview-container">
                        <div class="canvas-container">
                            <div class="canvas-wrapper" id="canvasWrapper">
                                <canvas id="drawCanvas" width="450" height="350"></canvas>
                                <canvas id="turtleCanvas" width="450" height="350"></canvas>
                            </div>

                            <div class="tooltip-box" id="tooltipBox">
                                <h4>üí° Dicas de Uso <button class="close-btn" onclick="closeTips()"
                                        title="Fechar dicas">√ó</button></h4>
                                <p><strong>B√°sico:</strong> Arraste blocos da esquerda para criar programas!</p>
                                <p><strong>Movimento:</strong> Use "mover" e "girar" para controlar o personagem.</p>
                                <p><strong>Repeti√ß√£o:</strong> Use loops para criar padr√µes interessantes.</p>
                                <p><strong>Dica:</strong> A caneta desenha quando est√° abaixada (padr√£o).</p>
                                <p style="margin-top: 0.5rem; font-size: 0.8rem; opacity: 0.8;">
                                    <strong>Atalhos:</strong> Ctrl+S (Salvar), Ctrl+R (Executar), Esc (Parar)
                                </p>
                            </div>

                            <div class="speed-control">
                                <span>‚ö° Velocidade:</span>
                                <input type="range" id="speedSlider" class="speed-slider" min="1" max="10" value="8">
                                <span id="speedValue">8</span>
                            </div>

                            <div class="zoom-controls">
                                <button class="zoom-btn" onclick="zoomIn()" title="Aumentar zoom">+</button>
                                <button class="zoom-btn" onclick="zoomOut()" title="Diminuir zoom">‚àí</button>
                                <button class="zoom-btn zoom-reset" onclick="resetZoom()"
                                    title="Resetar zoom">100%</button>
                            </div>

                            <div class="canvas-info" id="canvasInfo">
                                <div><strong>üéØ Posi√ß√£o:</strong> <span id="positionInfo">X: 225, Y: 175</span></div>
                                <div><strong>üß≠ Dire√ß√£o:</strong> <span id="angleInfo">0¬∞</span></div>
                                <div><strong>‚úèÔ∏è Caneta:</strong> <span id="penInfo">Abaixada</span></div>
                                <div><strong>üé® Cor:</strong> <span id="colorInfo">#2dcc70</span></div>
                                <div><strong>üîç Zoom:</strong> <span id="zoomInfo">100%</span></div>
                            </div>

                            <button class="grid-toggle" id="gridToggle" onclick="toggleGrid()"
                                title="Mostrar/ocultar grade">
                                üìê Grade
                            </button>
                        </div>
                    </div>

                    <div class="console-container" id="console">
                        <div class="console-line">üöÄ <strong>Bem-vindo ao CodeBlocos!</strong></div>
                        <div class="console-line">üéØ Arraste blocos do menu √† esquerda para criar seu programa</div>
                        <div class="console-line">üé® Veja a anima√ß√£o em tempo real no canvas acima!</div>
                        <div class="console-line">üí° Use os exemplos para come√ßar rapidamente</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Input oculto para carregar arquivos -->
    <input type="file" id="fileInput" accept=".json" style="display: none">

    <!-- Toolbox definition -->
    <xml id="toolbox" style="display: none">
        <category name="üöÄ Movimento" colour="#F39C12">
            <block type="move_forward"></block>
            <block type="turn_direction"></block>
            <block type="move_to"></block>
            <block type="set_color"></block>
            <block type="pen_up_down"></block>
            <block type="set_speed"></block>
        </category>
        <category name="üéõÔ∏è Controle" colour="#9B59B6">
            <block type="controls_repeat_ext">
                <value name="TIMES">
                    <shadow type="math_number">
                        <field name="NUM">5</field>
                    </shadow>
                </value>
            </block>
            <block type="controls_if"></block>
            <block type="controls_whileUntil"></block>
        </category>
        <category name="üî¢ Matem√°tica" colour="#E74C3C">
            <block type="math_number"></block>
            <block type="math_arithmetic"></block>
            <block type="logic_compare"></block>
            <block type="math_random_int">
                <value name="FROM">
                    <shadow type="math_number">
                        <field name="NUM">1</field>
                    </shadow>
                </value>
                <value name="TO">
                    <shadow type="math_number">
                        <field name="NUM">100</field>
                    </shadow>
                </value>
            </block>
        </category>
        <category name="‚úèÔ∏è Formas" colour="#1ABC9C">
            <block type="draw_circle"></block>
            <block type="draw_square"></block>
            <block type="draw_polygon"></block>
        </category>
        <category name="üé≤ Aleat√≥rio" colour="#3498DB">
            <block type="move_random"></block>
            <block type="random_color"></block>
            <block type="random_turn"></block>
        </category>
        <category name="‚è≥ Tempo" colour="#E67E22">
            <block type="wait_seconds"></block>
        </category>
        <category name="üí¨ Mensagens" colour="#2ECC71">
            <block type="log_message"></block>
            <block type="show_message"></block>
        </category>
        <category name="üì¶ Vari√°veis" custom="VARIABLE" colour="#FF9800"></category>
    </xml>

    <script>
        // Estado global da aplica√ß√£o
        let gameState = {
            turtle: {
                x: 225,
                y: 175,
                angle: 0,
                color: '#2dcc70',
                penDown: true,
                size: 12,
                speed: 8
            },
            isRunning: false,
            shouldStop: false,
            animationSpeed: 40, // Mais r√°pido
            trails: [],
            drawingPaths: [],
            showGrid: false,
            zoom: 1.0,
            minZoom: 0.5,
            maxZoom: 3.0
        };

        let workspace;
        let drawCanvas, drawCtx;
        let turtleCanvas, turtleCtx;

        // Inicializa√ß√£o
        function init() {
            initBlockly();
            initCanvas();
            initEventListeners();
            loadSavedWorkspace();
            resetCanvas();
            checkTipsVisibility();

            // Carregar exemplo inicial
            setTimeout(() => {
                loadExample('square');
                addConsoleLog('üìù Exemplo "Quadrado" carregado - clique em Executar!');
            }, 1000);
        }

        function resizeConsole(delta) {
            const consoleEl = document.getElementById('console');
            let newHeight = consoleEl.offsetHeight + delta;
            if (newHeight < 100) newHeight = 100; // limite m√≠nimo
            if (newHeight > 500) newHeight = 500; // limite m√°ximo
            consoleEl.style.height = newHeight + 'px';
        }


        function initBlockly() {
            workspace = Blockly.inject('blocklyDiv', {
                toolbox: document.getElementById('toolbox'),
                scrollbars: true,
                horizontalLayout: false,
                toolboxPosition: 'start',
                trashcan: true,
                sounds: true,
                grid: {
                    spacing: 20,
                    length: 3,
                    colour: '#e0e0e0',
                    snap: true
                },
                zoom: {
                    controls: true,
                    wheel: true,
                    startScale: 0.9,
                    maxScale: 3,
                    minScale: 0.3,
                    scaleSpeed: 1.2
                }
            });

            defineCustomBlocks();

            // Auto-salvar ao modificar workspace
            workspace.addChangeListener(function () {
                setTimeout(autoSave, 500);
            });
        }

        function initCanvas() {
            drawCanvas = document.getElementById('drawCanvas');
            drawCtx = drawCanvas.getContext('2d');
            turtleCanvas = document.getElementById('turtleCanvas');
            turtleCtx = turtleCanvas.getContext('2d');

            // Configurar anti-aliasing
            drawCtx.imageSmoothingEnabled = true;
            turtleCtx.imageSmoothingEnabled = true;
        }

        function initEventListeners() {
            document.getElementById('runButton').addEventListener('click', runProgram);
            document.getElementById('stopButton').addEventListener('click', stopProgram);
            document.getElementById('resetButton').addEventListener('click', resetCanvas);
            document.getElementById('saveButton').addEventListener('click', saveWorkspace);
            document.getElementById('loadButton').addEventListener('click', () => {
                document.getElementById('fileInput').click();
            });
            document.getElementById('exportButton').addEventListener('click', exportDrawing);
            document.getElementById('tipsButton').addEventListener('click', toggleTips);

            document.getElementById('fileInput').addEventListener('change', loadWorkspace);

            const speedSlider = document.getElementById('speedSlider');
            speedSlider.addEventListener('input', function () {
                gameState.animationSpeed = 200 - (this.value * 18); // Mais r√°pido
                gameState.turtle.speed = parseInt(this.value);
                document.getElementById('speedValue').textContent = this.value;
                updateCanvasInfo();
            });

            // Atalhos de teclado
            document.addEventListener('keydown', handleKeyboard);

            // Redimensionamento
            window.addEventListener('resize', handleResize);
        }

        function handleKeyboard(e) {
            if (e.ctrlKey || e.metaKey) {
                switch (e.key.toLowerCase()) {
                    case 's':
                        e.preventDefault();
                        saveWorkspace();
                        break;
                    case 'r':
                        e.preventDefault();
                        if (!gameState.isRunning) {
                            runProgram();
                        }
                        break;
                    case 'd':
                        e.preventDefault();
                        resetCanvas();
                        break;
                    case 'o':
                        e.preventDefault();
                        document.getElementById('fileInput').click();
                        break;
                }
            }

            if (e.key === 'Escape' && gameState.isRunning) {
                stopProgram();
            }
        }

        function handleResize() {
            setTimeout(() => {
                drawTurtle();
                redrawPaths();
            }, 100);
        }


        // Defini√ß√£o de blocos customizados
        function defineCustomBlocks() {
            // Bloco mover para frente (agora aceita vari√°veis ou n√∫meros)
            Blockly.Blocks['move_forward'] = {
                init: function () {
                    this.appendValueInput("DISTANCE")
                        .setCheck("Number")
                        .appendField("üöÄ mover");

                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#F39C12');
                    this.setTooltip('Move o personagem para frente com anima√ß√£o suave');

                    // N√∫mero padr√£o (shadow block)
                    this.getInput("DISTANCE").connection
                        .setShadowDom(Blockly.Xml.textToDom(`
                <shadow type="math_number">
                    <field name="NUM">50</field>
                </shadow>
            `));
                }
            };




            // Bloco girar
            Blockly.Blocks['turn_direction'] = {
                init: function () {
                    this.appendValueInput("ANGLE")
                        .setCheck("Number")
                        .appendField("üîÑ girar");

                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#F39C12');
                    this.setTooltip('Gira o personagem em graus com anima√ß√£o');

                    // N√∫mero padr√£o (shadow block)
                    this.getInput("ANGLE").connection
                        .setShadowDom(Blockly.Xml.textToDom(`
                <shadow type="math_number">
                    <field name="NUM">90</field>
                </shadow>
            `));
                }
            };



            // Bloco mover para posi√ß√£o
            Blockly.Blocks['move_to'] = {
                init: function () {
                    this.appendDummyInput()
                        .appendField("üìç ir para x:")
                        .appendField(new Blockly.FieldNumber(225, 0, 450), "X")
                        .appendField("y:")
                        .appendField(new Blockly.FieldNumber(175, 0, 350), "Y");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#F39C12');
                    this.setTooltip('Move o personagem para uma posi√ß√£o espec√≠fica');
                }
            };

            // Bloco mudar cor
            Blockly.Blocks['set_color'] = {
                init: function () {
                    this.appendDummyInput()
                        .appendField("üé® mudar cor para")
                        .appendField(new Blockly.FieldColour('#2dcc70'), "COLOR");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#F39C12');
                    this.setTooltip('Muda a cor do personagem e do desenho');
                }
            };

            // Bloco controlar caneta
            Blockly.Blocks['pen_up_down'] = {
                init: function () {
                    this.appendDummyInput()
                        .appendField("‚úèÔ∏è")
                        .appendField(new Blockly.FieldDropdown([
                            ['levantar caneta', 'UP'],
                            ['abaixar caneta', 'DOWN']
                        ]), "ACTION");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#F39C12');
                    this.setTooltip('Controla se o personagem desenha ao se mover');

                }
            };

            // Bloco definir velocidade
            Blockly.Blocks['set_speed'] = {
                init: function () {
                    this.appendDummyInput()
                        .appendField("‚ö° velocidade")
                        .appendField(new Blockly.FieldNumber(5, 1, 10), "SPEED");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#F39C12');
                    this.setTooltip('Define a velocidade de movimento do personagem');
                }
            };

            // Bloco desenhar c√≠rculo
            Blockly.Blocks['draw_circle'] = {
                init: function () {
                    this.appendDummyInput()
                        .appendField("‚≠ï desenhar c√≠rculo raio")
                        .appendField(new Blockly.FieldNumber(50, 5, 200), "RADIUS");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#1ABC9C');
                    this.setTooltip('Desenha um c√≠rculo com o raio especificado');
                }
            };

            // Bloco desenhar quadrado
            Blockly.Blocks['draw_square'] = {
                init: function () {
                    this.appendDummyInput()
                        .appendField("‚¨ú desenhar quadrado lado")
                        .appendField(new Blockly.FieldNumber(80, 5, 300), "SIZE");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#1ABC9C');
                    this.setTooltip('Desenha um quadrado com o tamanho especificado');
                }
            };

            // Bloco desenhar pol√≠gono
            Blockly.Blocks['draw_polygon'] = {
                init: function () {
                    this.appendDummyInput()
                        .appendField("üî∏ pol√≠gono")
                        .appendField(new Blockly.FieldNumber(6, 3, 12), "SIDES")
                        .appendField("lados, tamanho")
                        .appendField(new Blockly.FieldNumber(60, 10, 200), "SIZE");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#1ABC9C');
                    this.setTooltip('Desenha um pol√≠gono regular');
                }
            };

            // Bloco movimento aleat√≥rio
            Blockly.Blocks['move_random'] = {
                init: function () {
                    this.appendDummyInput()
                        .appendField("üé≤ mover aleat√≥rio")
                        .appendField(new Blockly.FieldNumber(100, 10, 300), "MAX_DISTANCE")
                        .appendField("passos");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#3498DB');
                    this.setTooltip('Move uma dist√¢ncia aleat√≥ria para frente');
                }
            };

            // Bloco cor aleat√≥ria
            Blockly.Blocks['random_color'] = {
                init: function () {
                    this.appendDummyInput()
                        .appendField("üåà cor aleat√≥ria");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#3498DB');
                    this.setTooltip('Muda para uma cor aleat√≥ria');
                }
            };

            // Bloco giro aleat√≥rio
            Blockly.Blocks['random_turn'] = {
                init: function () {
                    this.appendDummyInput()
                        .appendField("üéØ girar aleat√≥rio")
                        .appendField(new Blockly.FieldNumber(180, 10, 360), "MAX_ANGLE")
                        .appendField("graus");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#3498DB');
                    this.setTooltip('Gira um √¢ngulo aleat√≥rio');
                }
            };

            // Bloco esperar
            Blockly.Blocks['wait_seconds'] = {
                init: function () {
                    this.appendDummyInput()
                        .appendField("‚è≥ esperar")
                        .appendField(new Blockly.FieldNumber(1, 0.1, 10), "SECONDS")
                        .appendField("segundos");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#E67E22');
                    this.setTooltip('Pausa a execu√ß√£o por alguns segundos');
                }
            };

            // Bloco log
            Blockly.Blocks['log_message'] = {
                init: function () {
                    this.appendDummyInput()
                        .appendField("üí¨ dizer")
                        .appendField(new Blockly.FieldTextInput('Ol√°!'), "MESSAGE");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#2ECC71');
                    this.setTooltip('Exibe uma mensagem no console');
                }
            };

            // Bloco mostrar mensagem
            Blockly.Blocks['show_message'] = {
                init: function () {
                    this.appendDummyInput()
                        .appendField("üì¢ mostrar")
                        .appendField(new Blockly.FieldTextInput('Mensagem!'), "MESSAGE");
                    this.setPreviousStatement(true, null);
                    this.setNextStatement(true, null);
                    this.setColour('#2ECC71');
                    this.setTooltip('Mostra uma mensagem em popup');
                }
            };

            // Geradores JavaScript para os blocos customizados
            Blockly.JavaScript['move_forward'] = function (block) {
                const distance = Blockly.JavaScript.valueToCode(block, 'DISTANCE', Blockly.JavaScript.ORDER_ATOMIC) || 0;
                return `await moveForward(${distance});\n`;
            };

            Blockly.JavaScript['turn_direction'] = function (block) {
                const angle = Blockly.JavaScript.valueToCode(block, 'ANGLE', Blockly.JavaScript.ORDER_ATOMIC) || 0;
                return `await turnDirection(${angle});\n`;
            };

            Blockly.JavaScript['move_to'] = function (block) {
                const x = block.getFieldValue('X');
                const y = block.getFieldValue('Y');
                return `await moveTo(${x}, ${y});\n`;
            };

            Blockly.JavaScript['set_color'] = function (block) {
                const color = block.getFieldValue('COLOR');
                return `setColor('${color}');\n`;
            };

            Blockly.JavaScript['pen_up_down'] = function (block) {
                const action = block.getFieldValue('ACTION');
                return `setPen('${action}');\n`;
            };

            Blockly.JavaScript['set_speed'] = function (block) {
                const speed = block.getFieldValue('SPEED');
                return `setSpeed(${speed});\n`;
            };

            Blockly.JavaScript['draw_circle'] = function (block) {
                const radius = block.getFieldValue('RADIUS');
                return `await drawCircle(${radius});\n`;
            };

            Blockly.JavaScript['draw_square'] = function (block) {
                const size = block.getFieldValue('SIZE');
                return `await drawSquare(${size});\n`;
            };

            Blockly.JavaScript['draw_polygon'] = function (block) {
                const sides = block.getFieldValue('SIDES');
                const size = block.getFieldValue('SIZE');
                return `await drawPolygon(${sides}, ${size});\n`;
            };

            Blockly.JavaScript['move_random'] = function (block) {
                const maxDistance = block.getFieldValue('MAX_DISTANCE');
                return `await moveRandom(${maxDistance});\n`;
            };

            Blockly.JavaScript['random_color'] = function (block) {
                return `randomColor();\n`;
            };

            Blockly.JavaScript['random_turn'] = function (block) {
                const maxAngle = block.getFieldValue('MAX_ANGLE');
                return `await randomTurn(${maxAngle});\n`;
            };

            Blockly.JavaScript['wait_seconds'] = function (block) {
                const seconds = block.getFieldValue('SECONDS');
                return `await wait(${seconds * 1000});\n`;
            };

            Blockly.JavaScript['log_message'] = function (block) {
                const message = block.getFieldValue('MESSAGE');
                return `logMessage('${message}');\n`;
            };

            Blockly.JavaScript['show_message'] = function (block) {
                const message = block.getFieldValue('MESSAGE');
                return `showMessage('${message}');\n`;
            };
        }

        // Fun√ß√µes de execu√ß√£o
        async function runProgram() {
            if (gameState.isRunning) return;

            gameState.isRunning = true;
            gameState.shouldStop = false;

            const runButton = document.getElementById('runButton');
            const stopButton = document.getElementById('stopButton');

            runButton.disabled = true;
            stopButton.disabled = false;

            try {
                const code = Blockly.JavaScript.workspaceToCode(workspace);
                addConsoleLog('üöÄ Executando programa...');

                // Fun√ß√£o para executar c√≥digo ass√≠ncrono
                const AsyncFunction = Object.getPrototypeOf(async function () { }).constructor;
                const func = new AsyncFunction(code);

                await func();

                if (!gameState.shouldStop) {
                    addConsoleLog('‚úÖ Programa executado com sucesso!', 'success');
                }

            } catch (error) {
                addConsoleLog(`‚ùå Erro: ${error.message}`, 'error');
                console.error('Erro na execu√ß√£o:', error);
            } finally {
                gameState.isRunning = false;
                runButton.disabled = false;
                stopButton.disabled = true;

                if (gameState.shouldStop) {
                    addConsoleLog('‚èπÔ∏è Execu√ß√£o interrompida pelo usu√°rio');
                }
            }
        }

        function stopProgram() {
            gameState.shouldStop = true;
            gameState.isRunning = false;

            document.getElementById('runButton').disabled = false;
            document.getElementById('stopButton').disabled = true;
        }

        // Fun√ß√µes do personagem
        async function moveForward(distance) {
            if (gameState.shouldStop) return;

            const startX = gameState.turtle.x;
            const startY = gameState.turtle.y;
            const radians = gameState.turtle.angle * Math.PI / 180;
            const endX = startX + Math.cos(radians) * distance;
            const endY = startY + Math.sin(radians) * distance;

            // Verificar limites
            const finalX = Math.max(0, Math.min(450, endX));
            const finalY = Math.max(0, Math.min(350, endY));

            await animateMovement(startX, startY, finalX, finalY, distance);

            gameState.turtle.x = finalX;
            gameState.turtle.y = finalY;

            updateCanvasInfo();
            createSparkles();
        }

        async function turnDirection(angle) {
            if (gameState.shouldStop) return;

            const startAngle = gameState.turtle.angle;
            const endAngle = startAngle + angle;

            await animateRotation(startAngle, endAngle);

            gameState.turtle.angle = endAngle % 360;
            updateCanvasInfo();
        }

        async function moveTo(x, y) {
            if (gameState.shouldStop) return;

            const startX = gameState.turtle.x;
            const startY = gameState.turtle.y;
            const distance = Math.sqrt((x - startX) ** 2 + (y - startY) ** 2);

            await animateMovement(startX, startY, x, y, distance);

            gameState.turtle.x = x;
            gameState.turtle.y = y;

            updateCanvasInfo();
            createSparkles();
        }

        function setColor(color) {
            gameState.turtle.color = color;
            updateCanvasInfo();
            addConsoleLog(`üé® Cor alterada para ${color}`);
        }

        function setPen(action) {
            gameState.turtle.penDown = action === 'DOWN';
            updateCanvasInfo();
            addConsoleLog(`‚úèÔ∏è Caneta ${gameState.turtle.penDown ? 'abaixada' : 'levantada'}`);
        }

        function setSpeed(speed) {
            gameState.turtle.speed = speed;
            gameState.animationSpeed = 200 - (speed * 18); // Mais r√°pido
            document.getElementById('speedSlider').value = speed;
            document.getElementById('speedValue').textContent = speed;
            updateCanvasInfo();
        }

        async function drawCircle(radius) {
            if (gameState.shouldStop) return;

            const steps = Math.max(12, Math.floor(radius / 3));
            const angleStep = 360 / steps;
            const sideLength = 2 * Math.PI * radius / steps;

            for (let i = 0; i < steps; i++) {
                if (gameState.shouldStop) break;
                await moveForward(sideLength);
                await turnDirection(angleStep);
            }
        }

        async function drawSquare(size) {
            if (gameState.shouldStop) return;

            for (let i = 0; i < 4; i++) {
                if (gameState.shouldStop) break;
                await moveForward(size);
                await turnDirection(90);
            }
        }

        async function drawPolygon(sides, size) {
            if (gameState.shouldStop) return;

            const angle = 360 / sides;
            for (let i = 0; i < sides; i++) {
                if (gameState.shouldStop) break;
                await moveForward(size);
                await turnDirection(angle);
            }
        }

        async function moveRandom(maxDistance) {
            const distance = Math.random() * maxDistance;
            await moveForward(distance);
        }

        function randomColor() {
            const colors = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#FFA07A', '#98D8C8', '#F7DC6F', '#BB8FCE', '#85C1E9'];
            const color = colors[Math.floor(Math.random() * colors.length)];
            setColor(color);
        }

        async function randomTurn(maxAngle) {
            const angle = (Math.random() * 2 - 1) * maxAngle;
            await turnDirection(angle);
        }

        function wait(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function logMessage(message) {
            addConsoleLog(`üí¨ ${message}`);
        }

        function showMessage(message) {
            alert(message);
        }

        // Fun√ß√µes de anima√ß√£o
        async function animateMovement(startX, startY, endX, endY, distance) {
            const steps = Math.max(10, Math.floor(distance / 5));
            const stepX = (endX - startX) / steps;
            const stepY = (endY - startY) / steps;

            for (let i = 0; i <= steps; i++) {
                if (gameState.shouldStop) break;

                const currentX = startX + stepX * i;
                const currentY = startY + stepY * i;

                // Desenhar linha se caneta estiver abaixada
                if (gameState.turtle.penDown && i > 0) {
                    const prevX = startX + stepX * (i - 1);
                    const prevY = startY + stepY * (i - 1);
                    drawLine(prevX, prevY, currentX, currentY);
                }

                gameState.turtle.x = currentX;
                gameState.turtle.y = currentY;

                drawTurtle();
                createTrail();

                await wait(gameState.animationSpeed);
            }
        }

        async function animateRotation(startAngle, endAngle) {
            const steps = Math.max(5, Math.abs(endAngle - startAngle) / 10);
            const stepAngle = (endAngle - startAngle) / steps;

            for (let i = 0; i <= steps; i++) {
                if (gameState.shouldStop) break;

                gameState.turtle.angle = startAngle + stepAngle * i;
                drawTurtle();

                await wait(gameState.animationSpeed / 2);
            }
        }

        // Fun√ß√µes de desenho
        function drawLine(x1, y1, x2, y2) {
            drawCtx.beginPath();
            drawCtx.moveTo(x1, y1);
            drawCtx.lineTo(x2, y2);
            drawCtx.strokeStyle = gameState.turtle.color;
            drawCtx.lineWidth = 3;
            drawCtx.lineCap = 'round';
            drawCtx.stroke();

            // Armazenar caminho para redraw
            gameState.drawingPaths.push({
                x1, y1, x2, y2,
                color: gameState.turtle.color
            });
        }

        function drawTurtle() {
            turtleCtx.clearRect(0, 0, turtleCanvas.width, turtleCanvas.height);

            const x = gameState.turtle.x;
            const y = gameState.turtle.y;
            const angle = gameState.turtle.angle;
            const size = gameState.turtle.size;

            turtleCtx.save();
            turtleCtx.translate(x, y);
            turtleCtx.rotate((angle - 90) * Math.PI / 180);

            // Desenhar corpo da tartaruga
            turtleCtx.fillStyle = gameState.turtle.color;
            turtleCtx.beginPath();
            turtleCtx.moveTo(0, -size);
            turtleCtx.lineTo(-size / 2, size / 2);
            turtleCtx.lineTo(size / 2, size / 2);
            turtleCtx.closePath();
            turtleCtx.fill();

            // Desenhar borda
            turtleCtx.strokeStyle = '#2c3e50';
            turtleCtx.lineWidth = 2;
            turtleCtx.stroke();

            // Desenhar olhos
            turtleCtx.fillStyle = 'white';
            turtleCtx.beginPath();
            turtleCtx.arc(-size / 4, -size / 3, size / 6, 0, 2 * Math.PI);
            turtleCtx.arc(size / 4, -size / 3, size / 6, 0, 2 * Math.PI);
            turtleCtx.fill();

            turtleCtx.fillStyle = 'black';
            turtleCtx.beginPath();
            turtleCtx.arc(-size / 4, -size / 3, size / 10, 0, 2 * Math.PI);
            turtleCtx.arc(size / 4, -size / 3, size / 10, 0, 2 * Math.PI);
            turtleCtx.fill();

            turtleCtx.restore();
        }

        function createTrail() {
            const trail = document.createElement('div');
            trail.className = 'character-trail';
            trail.style.left = (gameState.turtle.x * gameState.zoom) + 'px';
            trail.style.top = (gameState.turtle.y * gameState.zoom) + 'px';
            trail.style.width = (6 * gameState.zoom) + 'px';
            trail.style.height = (6 * gameState.zoom) + 'px';
            trail.style.background = gameState.turtle.color;
            trail.style.opacity = '0.5';

            document.querySelector('.canvas-wrapper').appendChild(trail);

            setTimeout(() => {
                if (trail.parentNode) {
                    trail.parentNode.removeChild(trail);
                }
            }, 1500);
        }

        function createSparkles() {
            for (let i = 0; i < 3; i++) {
                setTimeout(() => {
                    const sparkle = document.createElement('div');
                    sparkle.className = 'sparkle';
                    sparkle.style.left = ((gameState.turtle.x + (Math.random() - 0.5) * 20) * gameState.zoom) + 'px';
                    sparkle.style.top = ((gameState.turtle.y + (Math.random() - 0.5) * 20) * gameState.zoom) + 'px';
                    sparkle.style.background = ['#FFD700', '#FF69B4', '#00CED1', '#FF6347'][Math.floor(Math.random() * 4)];

                    document.querySelector('.canvas-wrapper').appendChild(sparkle);

                    setTimeout(() => {
                        if (sparkle.parentNode) {
                            sparkle.parentNode.removeChild(sparkle);
                        }
                    }, 1000);
                }, i * 100);
            }
        }

        function redrawPaths() {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            drawGrid();

            gameState.drawingPaths.forEach(path => {
                drawCtx.beginPath();
                drawCtx.moveTo(path.x1, path.y1);
                drawCtx.lineTo(path.x2, path.y2);
                drawCtx.strokeStyle = path.color;
                drawCtx.lineWidth = 3;
                drawCtx.lineCap = 'round';
                drawCtx.stroke();
            });
        }

        function drawGrid() {
            if (!gameState.showGrid) return;

            drawCtx.strokeStyle = '#f0f0f0';
            drawCtx.lineWidth = 1;

            for (let x = 0; x <= 450; x += 25) {
                drawCtx.beginPath();
                drawCtx.moveTo(x, 0);
                drawCtx.lineTo(x, 350);
                drawCtx.stroke();
            }

            for (let y = 0; y <= 350; y += 25) {
                drawCtx.beginPath();
                drawCtx.moveTo(0, y);
                drawCtx.lineTo(450, y);
                drawCtx.stroke();
            }
        }

        // Fun√ß√µes de interface
        function resetCanvas() {
            drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
            turtleCtx.clearRect(0, 0, turtleCanvas.width, turtleCanvas.height);

            gameState.turtle.x = 225;
            gameState.turtle.y = 175;
            gameState.turtle.angle = 0;
            gameState.turtle.color = '#2dcc70';
            gameState.turtle.penDown = true;
            gameState.drawingPaths = [];

            drawGrid();
            drawTurtle();
            updateCanvasInfo();

            // Limpar rastros
            document.querySelectorAll('.character-trail, .sparkle').forEach(el => el.remove());

            addConsoleLog('üîÑ Canvas reiniciado');
        }

        function updateCanvasInfo() {
            document.getElementById('positionInfo').textContent = `X: ${Math.round(gameState.turtle.x)}, Y: ${Math.round(gameState.turtle.y)}`;
            document.getElementById('angleInfo').textContent = `${Math.round(gameState.turtle.angle)}¬∞`;
            document.getElementById('penInfo').textContent = gameState.turtle.penDown ? 'Abaixada' : 'Levantada';
            document.getElementById('colorInfo').textContent = gameState.turtle.color;
            document.getElementById('zoomInfo').textContent = `${Math.round(gameState.zoom * 100)}%`;
        }

        // Fun√ß√µes de zoom
        function zoomIn() {
            if (gameState.zoom < gameState.maxZoom) {
                gameState.zoom = Math.min(gameState.maxZoom, gameState.zoom + 0.2);
                applyZoom();
            }
        }

        function zoomOut() {
            if (gameState.zoom > gameState.minZoom) {
                gameState.zoom = Math.max(gameState.minZoom, gameState.zoom - 0.2);
                applyZoom();
            }
        }

        function resetZoom() {
            gameState.zoom = 1.0;
            applyZoom();
        }

        function applyZoom() {
            const canvasWrapper = document.getElementById('canvasWrapper');
            canvasWrapper.style.transform = `scale(${gameState.zoom})`;
            updateCanvasInfo();

            // Limpar rastros existentes para evitar problemas de escala
            document.querySelectorAll('.character-trail, .sparkle').forEach(el => el.remove());
        }

        function addConsoleLog(message, type = 'normal') {
            const console = document.getElementById('console');
            const line = document.createElement('div');
            line.className = `console-line ${type === 'error' ? 'error-message' : type === 'success' ? 'success-message' : ''}`;
            line.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;

            console.appendChild(line);
            console.scrollTop = console.scrollHeight;

            // Limitar n√∫mero de linhas
            while (console.children.length > 50) {
                console.removeChild(console.firstChild);
            }
        }

        function toggleGrid() {
            gameState.showGrid = !gameState.showGrid;
            redrawPaths();
            drawTurtle();

            const button = document.getElementById('gridToggle');
            button.textContent = gameState.showGrid ? 'üìê Ocultar Grade' : 'üìê Grade';
        }

        function toggleTips() {
            const tooltipBox = document.getElementById('tooltipBox');
            tooltipBox.classList.toggle('hidden');
        }

        function closeTips() {
            document.getElementById('tooltipBox').classList.add('hidden');
        }

        function checkTipsVisibility() {
            const hasSeenTips = localStorage.getItem('codeblocos_tips_seen');
            if (hasSeenTips) {
                document.getElementById('tooltipBox').classList.add('hidden');
            }
        }

        // Fun√ß√µes de salvamento
        function saveWorkspace() {
            try {
                const xml = Blockly.Xml.workspaceToDom(workspace);
                const xmlText = Blockly.Xml.domToPrettyText(xml);

                const blob = new Blob([xmlText], { type: 'application/xml' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `codeblocos_${new Date().toISOString().slice(0, 10)}.xml`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);

                URL.revokeObjectURL(url);

                addConsoleLog('üíæ Programa salvo com sucesso!');
            } catch (error) {
                addConsoleLog(`‚ùå Erro ao salvar: ${error.message}`, 'error');
            }
        }

        function loadWorkspace(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const xmlText = e.target.result;
                    const xmlDom = Blockly.Xml.textToDom(xmlText);

                    workspace.clear();
                    Blockly.Xml.domToWorkspace(xmlDom, workspace);

                    addConsoleLog('üìÇ Programa carregado com sucesso!');
                } catch (error) {
                    addConsoleLog(`‚ùå Erro ao carregar arquivo: ${error.message}`, 'error');
                }
            };
            reader.readAsText(file);
        }

        function autoSave() {
            try {
                const xml = Blockly.Xml.workspaceToDom(workspace);
                const xmlText = Blockly.Xml.domToText(xml);
                localStorage.setItem('codeblocos_autosave', xmlText);
            } catch (error) {
                console.warn('Erro no auto-save:', error);
            }
        }

        function loadSavedWorkspace() {
            try {
                const savedXml = localStorage.getItem('codeblocos_autosave');
                if (savedXml) {
                    const xmlDom = Blockly.Xml.textToDom(savedXml);
                    Blockly.Xml.domToWorkspace(xmlDom, workspace);
                }
            } catch (error) {
                console.warn('Erro ao carregar workspace salvo:', error);
            }
        }

        function exportDrawing() {
            try {
                const canvas = document.createElement('canvas');
                canvas.width = drawCanvas.width;
                canvas.height = drawCanvas.height;
                const ctx = canvas.getContext('2d');

                // Fundo branco
                ctx.fillStyle = 'white';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Copiar desenho
                ctx.drawImage(drawCanvas, 0, 0);

                // Download
                const link = document.createElement('a');
                link.download = `codeblocos_desenho_${new Date().toISOString().slice(0, 10)}.png`;
                link.href = canvas.toDataURL();
                link.click();

                addConsoleLog('üñºÔ∏è Desenho exportado com sucesso!');
            } catch (error) {
                addConsoleLog(`‚ùå Erro ao exportar: ${error.message}`, 'error');
            }
        }

        // Exemplos pr√©-definidos
        function loadExample(type) {
            workspace.clear();
            let xml = '';

            switch (type) {
                case 'square':
                    xml = `<xml>
                        <block type="set_color" x="70" y="70">
                            <field name="COLOR">#e74c3c</field>
                            <next>
                                <block type="controls_repeat_ext">
                                    <value name="TIMES">
                                        <shadow type="math_number">
                                            <field name="NUM">4</field>
                                        </shadow>
                                    </value>
                                    <statement name="DO">
                                        <block type="move_forward">
                                            <field name="DISTANCE">100</field>
                                            <next>
                                                <block type="turn_direction">
                                                    <field name="ANGLE">90</field>
                                                </block>
                                            </next>
                                        </block>
                                    </statement>
                                </block>
                            </next>
                        </block>
                    </xml>`;
                    break;

                case 'spiral':
                    xml = `<xml>
                        <block type="set_color" x="70" y="70">
                            <field name="COLOR">#3498db</field>
                            <next>
                                <block type="controls_repeat_ext">
                                    <value name="TIMES">
                                        <shadow type="math_number">
                                            <field name="NUM">36</field>
                                        </shadow>
                                    </value>
                                    <statement name="DO">
                                        <block type="move_forward">
                                            <field name="DISTANCE">5</field>
                                            <next>
                                                <block type="turn_direction">
                                                    <field name="ANGLE">91</field>
                                                </block>
                                            </next>
                                        </block>
                                    </statement>
                                </block>
                            </next>
                        </block>
                    </xml>`;
                    break;

                case 'flower':
                    xml = `<xml>
                        <block type="set_color" x="70" y="70">
                            <field name="COLOR">#e91e63</field>
                            <next>
                                <block type="controls_repeat_ext">
                                    <value name="TIMES">
                                        <shadow type="math_number">
                                            <field name="NUM">8</field>
                                        </shadow>
                                    </value>
                                    <statement name="DO">
                                        <block type="draw_circle">
                                            <field name="RADIUS">30</field>
                                            <next>
                                                <block type="turn_direction">
                                                    <field name="ANGLE">45</field>
                                                </block>
                                            </next>
                                        </block>
                                    </statement>
                                    <next>
                                        <block type="set_color">
                                            <field name="COLOR">#4caf50</field>
                                            <next>
                                                <block type="turn_direction">
                                                    <field name="ANGLE">-90</field>
                                                    <next>
                                                        <block type="move_forward">
                                                            <field name="DISTANCE">60</field>
                                                        </block>
                                                    </next>
                                                </block>
                                            </next>
                                        </block>
                                    </next>
                                </block>
                            </next>
                        </block>
                    </xml>`;
                    break;

                default:
                    return;
            }

            try {
                const xmlDom = Blockly.Xml.textToDom(xml);
                Blockly.Xml.domToWorkspace(xmlDom, workspace);
                addConsoleLog(`üìù Exemplo "${type}" carregado!`);
            } catch (error) {
                addConsoleLog(`‚ùå Erro ao carregar exemplo: ${error.message}`, 'error');
            }
        }

        // Inicializar aplica√ß√£o quando DOM estiver pronto
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>

</html>